package com.smartdline.watcher.service;

import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.Date;

import android.text.TextUtils;

import com.roidlibrary.utils.Logger;
import com.smartdline.watcher.common.BluetoothCmd;
import com.smartdline.watcher.common.Constants;
import com.smartdline.watcher.utils.BCDUtil;

public class BluetoothEncoderService {

	private static final String TAG = BluetoothEncoderService.class.getSimpleName();
	
	private static BluetoothEncoderService mBluetoothEncoderService;

	public static BluetoothEncoderService getInstance() {
		if (null == mBluetoothEncoderService) {
			synchronized (BluetoothEncoderService.class) {
				if (null == mBluetoothEncoderService) {
					mBluetoothEncoderService = new BluetoothEncoderService();
				}
			}
		}
		return mBluetoothEncoderService;
	}

	/**
	 * 发送ack(APP端收到手表数据，后发送确认码) 发送uuid:fff3
	 * 
	 * @return
	 */
	public byte[] sendAck() {
		return sendAck(BluetoothCmd.SEND_ACK);
	}

	/**
	 * 发送ack(APP端收到手表数据，后发送确认码) 发送uuid:fff3
	 * 
	 * @param cmd
	 * @return
	 */
	public byte[] sendAck(byte cmd) {
		byte[] ack = new byte[1];
		ack[0] = cmd;
		return ack;
	}

	/**
	 * 手机发送电话 发送uuid:fff1 返回uuid:fff4 (0x01 或者0x81)
	 * 
	 * @param cmd
	 *            命令字0x01（英文） 0x81(中文)
	 * @param status
	 *            0x01-->来电话 0x00--->电话已经结束
	 * @param nameLen
	 *            名字长度(长度小于等于8)如果是中英文混合就发送为中文，超过长度就提示输入长度不能超过6个字节
	 * @param name
	 * @param phoneLen
	 *            有效bcd的个数，最大14,如果超过14位，只发送后面的14位
	 * @param phoneNumber
	 *            (bcd码,+用a表示)
	 * @return
	 */
	public byte[] sendPhone(byte cmd, byte status, String name,
			String phoneNumber) {
		byte[] phone=null;
		try {
			if (TextUtils.isEmpty(name)) {
				name="UNKNOWN";
			}

			if (TextUtils.isEmpty(phoneNumber)) {
				return null;
			}

			phone = new byte[20];
			phone[0] = cmd;
			phone[1] = status;

			byte[] nameByte = name.getBytes(Constants.GBK);
			
			//如果超出8字节，则复制出前面8个字节
			byte nameLen=0;
			if (nameByte.length > 8) {
				nameLen=8;
			}else{
				nameLen = (byte) nameByte.length;
			}
			phone[2] = nameLen;
			System.arraycopy(nameByte, 0, phone, 3, nameLen);
			

			String phones = "";
			if (phoneNumber.startsWith("+")) {
				phones = phoneNumber.substring(phoneNumber.length()-3, phoneNumber.length());
			}else{
				phones=phoneNumber;
			}
			byte phoneLen = (byte) phones.length();
			phone[2 + nameLen + 1] = phoneLen;
//			phone[2 + nameLen + 2] = 0x0a;
//			byte[] phoneByte = BCDUtil.str2Bcd(phones.substring(1));
			byte[] phoneByte = BCDUtil.str2Bcd(phones);
			System.arraycopy(phoneByte, 0, phone, nameLen + 4, phoneByte.length);
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return phone;
	}

	/**
	 * 手机发送短信--第一个包
	 * 
	 * @param cmd
	 * @param packetIndex
	 * @param nameLen
	 * @param name
	 * @param phoneLen
	 * @param phoneName
	 * @param currentPackLen
	 * @param currentPackName
	 * @return
	 */
	public byte[] sendMessage(byte cmd, int totalPackegs,String name,String phoneNumber) {
		byte[] message = new byte[20];
		message[0] = cmd;
		message[1] = 0x00;
		
		byte[] nameByte=null;
		try {
			nameByte = name.getBytes(Constants.GBK);
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		message[2] = (byte) totalPackegs;
		
		//如果超出8字节，则复制出前面8个字节
		byte nameLen=0;
		if (nameByte.length > 8) {
			nameLen=8;
		}else{
			nameLen = (byte) nameByte.length;
		}
		message[3] = nameLen;
		System.arraycopy(nameByte, 0, message, 4, nameByte.length);
		
		
		String phones = "";
		if (phoneNumber.startsWith("+")) {
			phones = phoneNumber.substring(phoneNumber.length()-3, phoneNumber.length());
		}else{
			phones=phoneNumber;
		}
		Logger.e(TAG, "phones:"+phones);
		byte phoneLen = (byte) phones.length();
		Logger.e(TAG, "phoneLen:"+phoneLen);
		message[4+nameByte.length] = phoneLen;
//		message[5+nameByte.length] = 0x0a;
//		byte[] phoneByte = BCDUtil.str2Bcd(phones.substring(1));
		byte[] phoneByte = BCDUtil.str2Bcd(phones);
		System.arraycopy(phoneByte, 0, message, 5+nameByte.length, phoneByte.length);
		
		return message;
	}

	/**
	 * 手机发送短信--第二~N个包
	 * 
	 * @param cmd
	 * @param packetIndex
	 * @param currentPackLen
	 * @param currentPackData
	 * @return
	 */
	public byte[] sendMessage(byte cmd, int packetIndex, int totalPackegs,int currentPackLen,
			byte[] currentPackData) {
		
		byte[] message = new byte[20];
		message[0] = cmd;
		message[1] = (byte) packetIndex;
		message[2] = (byte) totalPackegs;
		message[3] = (byte) currentPackLen;
		System.arraycopy(currentPackData, 0, message, 4, currentPackData.length);

		return message;
	}

	/**
	 * 手机发送时间 发送UUID:fff1 返回值：fff4 (0x03)，手表发送ack
	 * 
	 * @param cmd
	 *            0x03
	 * @param date example:new Date();
	 * @return
	 */
	public byte[] sendTime(byte cmd, Date date) {
		byte[] time = new byte[20];
		time[0] = cmd;
		time[1] = 0x06;
		
		SimpleDateFormat sdf = new SimpleDateFormat("yyMMddHHmmss");
		byte[] bcdTime = BCDUtil.str2Bcd(sdf.format(date));
		System.arraycopy(bcdTime, 0, time, 2, bcdTime.length);

		return time;
	}
	
	/**
	 * 手机发送名字 发送UUID:fff1 返回值：fff4 (0x04或0x84)，手表发送ack
	 * 
	 * @param cmd
	 *            0x04(0x84)
	 * @param name1 name1 length<=6
	 * @param name2 name2 length<=6
	 * @return
	 */
	public byte[] settingName(byte cmd, String name1,String name2) {
		byte[] name=null;
		try {
			name = new byte[20];
			name[0] = cmd;
			
			byte[] name1Byte = name1.getBytes(Constants.GBK);
			name[1] = (byte) name1Byte.length;
			System.arraycopy(name1Byte, 0, name, 2, name1Byte.length);
			
			if(!TextUtils.isEmpty(name2)){
				byte[] name2Byte = name2.getBytes(Constants.GBK);
				name[2+name1Byte.length] = (byte) name2Byte.length;
				System.arraycopy(name2Byte, 0, name, 3+name1Byte.length, name2Byte.length);
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return name;
	}
	
	/**
	 * 手机发送名字 发送UUID:fff1 返回值：fff4 (0x04或0x84)，手表发送ack
	 * 
	 * @param cmd
	 *            0x04(0x84)
	 * @param name1 name1 length<=6
	 * @return
	 */
	public byte[] settingName(byte cmd, String name1) {

		return settingName(cmd,name1,null);
	}
	
	/**
	 * 手机查询  发送UUID:fff3 返回值：fff2
	 * @param cmd 0x05
	 * @return
	 */
	public byte[] query(byte cmd) {
		
		byte[] query = new byte[1];
		query[0] = cmd;

		return query;
	}
	
	
	/**
	 * 手机设置提醒 发送UUID:fff1 返回值：fff4，手表发送ack(0x07)
	 * @param cmd 0x07
	 * @param type 附录1：（提醒type）
	 * @param month 月 (08月23日--08)
	 * @param day 日 (08月23日--23)
	 * @return
	 */
	public byte[] settingRemind(byte cmd,int type,int month,int day) {
		
		byte[] remind = new byte[20];
		remind[0] = cmd;
		remind[1] = (byte) type;
		remind[2] = (byte) month;
		remind[3] = (byte) day;

		return remind;
	}
	
	/**
	 * 手机设置提醒 发送UUID:fff1 返回值：fff4，手表发送ack(0x07)
	 * @param cmd 0x07
	 * @param type 附录1：（提醒type）
	 * @param month 月 (08月23日--08)
	 * @param day 日 (08月23日--23)
	 * @return
	 */
	public byte[] settingRemind(byte cmd,int type,int month,int day,int hour,int min) {
		
		byte[] remind = new byte[20];
		remind[0] = cmd;
		remind[1] = (byte) type;
		remind[2] = (byte) month;
		remind[3] = (byte) day;
		remind[4] = (byte) hour;
		remind[5] = (byte) min;

		return remind;
	}
	
	
	/**
	 * 手机设置提醒 发送UUID:fff1 返回值：fff4，手表发送ack（0x09）
	 * @param cmd 0x09
	 * @param turn 设备序号(0-4)
	 * @param name 长度<=6
	 * @return
	 */
	public byte[] settingFittingName(byte cmd,int turn,String name) {
		
		byte[] remind = new byte[20];
		remind[0] = cmd;
		remind[1] = (byte) turn;
		
		byte[] nameByte=null;
		try {
			nameByte = name.getBytes(Constants.GBK);
			remind[2] = (byte) nameByte.length;
			System.arraycopy(nameByte, 0, remind, 3, nameByte.length);
		} catch (UnsupportedEncodingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		

		return remind;
	}
	
	
	/**
	 * 设置免打扰时段  发送UUID:fff1 返回值：fff4，手表发送ack（0x09）
	 * @param cmd 0x0b
	 * @param turn 参数为0到2共3个
	 * @param startHour
	 * @param startMin
	 * @param endHour
	 * @param endMin
	 * @param week 第0到6位，分别对应星期1到星期日，为真表示有效
	 * @return
	 */
	public byte[] settingDistubTime(byte cmd,byte turn,int startHour,int startMin,int endHour,int endMin,int week) {
		
		byte[] distub = new byte[20];
		distub[0] = cmd;
		distub[1] = turn;
		
		distub[2] = (byte) startHour;
		distub[3] = (byte) startMin;
		distub[4] = (byte) endHour;
		distub[5] = (byte) endMin;
		distub[6] = (byte) week;
		
		return distub;
	}
	
	/**
	 * 设置计步器参数 UUID:fff1  返回值：fff4，手表发送ack（0x0e）
	 * @param cmd 0x0e
	 * @param hight 身高(单位cm)
	 * @param weight 体重(单位kg)
	 * @return
	 */
	public byte[] settingCalSteps(byte cmd,int hight,int weight) {
		
		byte[] steps = new byte[20];
		steps[0] = cmd;
		steps[1] = (byte) hight;
		steps[2] = (byte) weight;
		
		return steps;
	}
}
